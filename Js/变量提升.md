### 变量提升
### 1.声明和定义
在讲变量提升的前面，我们需要先了解 `js` 变量的声明和定义；声明即是指创建了一个变量，而定义则是我们常说的赋值；
+ 声明：var num;意思是告诉浏览器或者当前执行环境，有一个叫num的变量，在遇到定义（赋值）之前，这个变量会被赋默认的`undefined`
+ 定义：num=12;告诉浏览器或者执行环境，变量num的值是12

### 2.变量提升
变量提升是js代码的预解释造成的，预解释是在栈内存进行的
变量提升是指运行环境会将`当前作用域`下使用`var/function`声明的变量提升到作用域的顶部；`let&const`是不存在变量提升的；

但是对于`var`和`function`，提升的策略是不一样的

+ 对于`var`：仅提升声明不提升定义
  ```
  var a=1;
  //等效于
  var a;
  a=1;
  ```
  `a=1`这条语句的位置就是`var a = 1`的位置，而`var a`则已经被提升到了顶部并被赋值`undefined`，所以在遇到 `a=1` 之前访问a，都会得到undefined


+ 对于`function`:提升声明和定义
  ```
  a();//输出a
  function a(){
    console.log('a')
  }
  ```
  我们会发现函数可以在声明语句出现之前使用，这就是因为函数的声明和定义都被提前了；
  

+ function和var的优先级
  
  优先级：function > var
  
  可以写一个简单的小例子来进行说明
  ```
  var a = 1;
  function a(){
    console.log('a')
  }
  console.log(a)//会输出1
  ```
  原因：在代码中我们使用var和function分别创建了一个变量和一个函数，但是函数和变量重名了，按照代码给出的顺序，最终输出的a应该是a函数的函数体，但是事实并不是这样的，事实是函数输出了1
  
  这是因为函数提升的优先级高于变量，所以一开始a函数就被提升了，紧接着提升了变量a，由于重名，变量a就将函数a覆盖掉了

  导致最后输出1

### 3.关于变量提升的其他情况
#### 3.1 函数声明式和函数表达式的提升区别
函数声明式
```
function a(){}
```

函数表达式
```
var a = function(){}
```
通过代码可以看到函数表达式将函数赋值给了一个变量a，在进行提升的就只会提升变量a，而不会提升后面的函数体，因为`等号左边`的才是变量，右边已经是值了，即函数体现在是作为一个值存在；

而函数表达式则不存在这种情况，直接是定义和声明一起提升，在该作用域的任何位置都可以进行调用

#### 3.2全局作用域下，变量有var和没var的区别
在window全局环境下；

变量有var，会创建一个全局变量，并且会给全局对象创建一个同名属性；且能够进行提升，在赋值语句之前访问会返回undefined

变量没var：不会声明为全局变量，会被创建为全局对象的属性；在该语句之前访问变量会报错；报引用错误，因为暂时还不存在该变量

#### 3.3 下面这种情况会输出什么？
```
if(!('num' in window)){
	var num = 12;
}
clg(num)
```
会输出`undefined`，因为var是`没有块级作用域`的概念的，所以if不会形成一个作用域，在if内部声明的变量就是在全局范围中的变量，这样变量就会被预解释，所以window就会有num属性，造成if判断`不成功`，不会执行内部的赋值语句；
